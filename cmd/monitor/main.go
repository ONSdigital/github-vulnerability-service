package main

import (
	"context"
	"fmt"
	"log"
	"os"

	// See: https://blog.machinebox.io/a-graphql-client-library-for-go-5bffd0455878
	"github.com/machinebox/graphql"
)

// Various fixed values for interacting with the Github graphql api
const (
	APIURL        = "https://api.github.com/graphql"
	PreviewHeader = "application/vnd.github.vixen-preview+json"
)

type response interface {
	repos() repositories
}

type repositories struct {
	TotalCount int
	Nodes      []struct {
		Name                string
		VulnerabilityAlerts struct {
			TotalCount int
			Nodes      []struct {
				AffectedRange string
				DismissReason string
				DismissedAt   string
				Dismisser     struct {
					Name string
				}
				ExternalIdentifier string
				ExternalReference  string
				FixedIn            string
				PackageName        string
				ID                 string
			}
		}
	}
}

type orgResponse struct {
	Organization struct {
		Team struct {
			Repositories repositories
		}
	}
}

func (r orgResponse) repos() repositories {
	return r.Organization.Team.Repositories
}

type userResponse struct {
	User struct {
		Repositories repositories
	}
}

func (r userResponse) repos() repositories {
	return r.User.Repositories
}

func main() {

	var token string
	if token = os.Getenv("TOKEN"); len(token) == 0 {
		log.Fatal("Must set Github API TOKEN env var")
	}

	org := os.Getenv("GITHUB_ORG")
	team := os.Getenv("GITHUB_TEAM")
	user := os.Getenv("GITHUB_USER")

	var userMode bool

	switch {
	case len(user) > 0:
		userMode = true
		log.Printf("Starting in USER mode for '%s'\n", user)
	case len(team) > 0 && len(org) > 0:
		userMode = false
		log.Printf("Starting in TEAM mode for '%s:%s'\n", org, team)
	default:
		log.Fatal("Must set either USER or ORG and TEAM env vars")
	}

	log.Printf("Usermode? %v\n", userMode)

	// Client is safe reusable across requests
	client := graphql.NewClient(APIURL)

	coreRequest := `
	repositories(first: 100) {
		totalCount
		nodes {
			name
			vulnerabilityAlerts(first: 10) {
				totalCount
				nodes {
					affectedRange
					dismissReason
					dismissedAt
					dismisser{
						name
					}
					externalIdentifier
					externalReference
					fixedIn
					id
					packageName
				}
			}
		}
	}
	`

	var req *graphql.Request
	if userMode {
		req = graphql.NewRequest(`
		query($user: String!) {
			user(login: $user) {
				` + coreRequest + `
			}
		}
		`)
		req.Var("user", user)
	} else {
		req = graphql.NewRequest(`
		query($organization: String!, $team: String!) {
			organization(login: $organization) {
				team(slug: $team) {
					` + coreRequest + `
				}
			}
		}
		`)
		req.Var("organization", org)
		req.Var("team", team)
	}

	req.Header.Set("Authorization", "bearer "+token)

	// Require the preview header if the features we require
	// aren't in the main release yet
	if len(PreviewHeader) > 0 {
		req.Header.Set("Accept", PreviewHeader)
	}

	ctx := context.Background()
	var res response
	if userMode {
		res = &userResponse{}
	} else {
		res = &orgResponse{}
	}

	if err := client.Run(ctx, req, &res); err != nil {
		log.Fatal(err)
	}

	// TODO needs better deduping of vulnerability packages and CVEs
	// This is needed as they can be listed more than once if the same thing
	// is found in several places. For our purposes we don't care _where_
	// something is found, just that it currently exists.

	// Simple listing of repos with vulnerabilities
	// for _, repo := range res.Organization.Team.Repositories.Nodes {
	for _, repo := range res.repos().Nodes {
		if repo.VulnerabilityAlerts.TotalCount > 0 {
			fmt.Printf("%s\n", repo.Name)

			// Group vulnerabilities by package
			groups := make(map[string][]string)
			for _, vuln := range repo.VulnerabilityAlerts.Nodes {
				groups[vuln.PackageName] = append(groups[vuln.PackageName], fmt.Sprintf("[%s](%s) {%s}", vuln.ExternalIdentifier, vuln.ExternalReference, vuln.DismissReason))
			}

			// List out the vulnerabilities
			for pkg, vulns := range groups {
				fmt.Printf("\t%s\n", pkg)
				for _, v := range vulns {
					fmt.Printf("\t\t%s\n", v)
				}
			}
		}
	}

}
