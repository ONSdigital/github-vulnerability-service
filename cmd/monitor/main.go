package main

// See: https://blog.machinebox.io/a-graphql-client-library-for-go-5bffd0455878

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"syscall"
	"time"

	"github.com/ONSdigital/github-vulnerability-monitor/pkg/api"
	"github.com/ONSdigital/github-vulnerability-monitor/pkg/signals"
	"github.com/julienschmidt/httprouter"
	"github.com/machinebox/graphql"
	"github.com/pkg/errors"
	"github.com/robfig/cron"
)

// Various fixed values for interacting with the Github graphql api
const (
	APIURL        = "https://api.github.com/graphql"
	PreviewHeader = "application/vnd.github.vixen-preview+json"
)

// The cache of the currently loaded vulnerability report
// var report map[string]map[string]vulnerability

type vulnMap map[string]map[string]Vulnerability

// Report is the representation of the vulnerability report
type Report struct {
	Team                     string  `json:"team,omitempty"`
	User                     string  `json:"user,omitempty"`
	Org                      string  `json:"org,omitempty"`
	LastChecked              string  `json:"lastChecked"`
	NextCheckScheduled       string  `json:"nextCheckScheduled"`
	DismissedVulnerabilities int     `json:"dismissedVulnerabilities"`
	Repos                    vulnMap `json:"repos"`
}

var report Report

// Vulnerability describes a vulnerability reported for a repository
type Vulnerability struct {
	AffectedRange string `json:"affectedRange,omitempty"`
	DismissReason string `json:"dismissReason,omitempty"`
	DismissedAt   string `json:"dismissedAt,omitempty"`
	Dismisser     *struct {
		Name string `json:"name,omitempty"`
	} `json:"dimisser,omitempty"`
	ExternalIdentifier string `json:"externalIdentifier,omitempty"`
	ExternalReference  string `json:"externalReference,omitempty"`
	FixedIn            string `json:"fixedIn,omitempty"`
	PackageName        string `json:"packageName,omitempty"`
	ID                 string `json:"id"`
}

type response interface {
	repos() repositories
}

type repositories struct {
	TotalCount int
	Nodes      []struct {
		Name                string
		VulnerabilityAlerts struct {
			TotalCount int
			PageInfo   struct {
				EndCursor       string
				HasNextPage     bool
				HasPreviousPage bool
				StartCursor     string
			}
			Nodes []Vulnerability
		}
	}
}

type teamResponse struct {
	Organization struct {
		Team struct {
			Repositories repositories
		}
	}
}

func (r teamResponse) repos() repositories {
	return r.Organization.Team.Repositories
}

type userResponse struct {
	User struct {
		Repositories repositories
	}
}

func (r userResponse) repos() repositories {
	return r.User.Repositories
}

var (
	token string // Github API access token
	port  string // Port on which to listen for webhooks

	logE = log.New(os.Stderr, "", log.Ldate|log.Ltime)

	org, team, user string

	lastUpdated time.Time

	c   *cron.Cron
	srv *http.Server
)

func main() {
	log.SetOutput(os.Stdout)

	if token = os.Getenv("TOKEN"); len(token) == 0 {
		logE.Fatal("Must set Github API TOKEN env var")
	}

	if port = os.Getenv("PORT"); len(port) == 0 {
		logE.Fatal(`event="Failed to start" error="missing PORT env"`)
	}

	var crontab string
	if crontab = os.Getenv("CRONTAB"); len(crontab) == 0 {
		logE.Fatal("Must set CRONTAB env var")
	}

	org = os.Getenv("GITHUB_ORG")
	team = os.Getenv("GITHUB_TEAM")
	user = os.Getenv("GITHUB_USER")

	// Initialise report storage
	report = Report{
		Repos: make(vulnMap),
		Team:  team,
		User:  user,
		Org:   org,
	}

	log.Printf(`event="Starting up" user="%s" team="%s" org="%s" cron="%s"`, user, team, org, crontab)

	client := graphql.NewClient(APIURL)

	// Start up the cron watcher to periodically check for updates
	c = cron.New()
	c.AddFunc(crontab, func() { fetchVulnerabilityReport(client) })
	c.Start()

	// Bootstrap an initial vulneranility report
	fetchVulnerabilityReport(client)

	// Start up the webserver to watch for webhooks
	cancelSigWatch := signals.HandleFunc(
		func(sig os.Signal) {
			log.Printf(`event="Shutting down" signal="%s"`, sig.String())

			if c != nil {
				log.Printf(`event="Stopping cron"`)
				c.Stop()
			}

			if srv != nil {
				log.Printf(`event="Stopping webserver"`)
				srv.Shutdown(context.Background())
			}

			log.Print(`event="Exiting"`)
			os.Exit(0)
		},
		syscall.SIGTERM,
		syscall.SIGINT,
	)
	defer cancelSigWatch()

	startWebserver()
}

func fetchVulnerabilityReport(client *graphql.Client) {

	log.Println(`event="Calling github api"`)

	coreRequest := `
	repositories(first: 100) {
		totalCount
		nodes {
			name
			vulnerabilityAlerts(first: 10) {
				totalCount
				pageInfo {
					endCursor
					hasNextPage
					hasPreviousPage
					startCursor
				}
				nodes {
					affectedRange
					dismissReason
					dismissedAt
					dismisser{
						name
					}
					externalIdentifier
					externalReference
					fixedIn
					id
					packageName
				}
			}
		}
	}
	`

	var req *graphql.Request
	var res response

	switch {
	default:
		logE.Fatal(`event="Exiting" error="Must set either USER or ORG and TEAM env vars"`)

	case len(user) > 0:
		req = graphql.NewRequest(`
		query($user: String!) {
			user(login: $user) {
				` + coreRequest + `
			}
		}
		`)
		req.Var("user", user)

		res = &userResponse{}

	case len(team) > 0 && len(org) > 0:
		req = graphql.NewRequest(`
		query($organization: String!, $team: String!) {
			organization(login: $organization) {
				team(slug: $team) {
					` + coreRequest + `
				}
			}
		}
		`)
		req.Var("organization", org)
		req.Var("team", team)

		res = &teamResponse{}
	}

	req.Header.Set("Authorization", "bearer "+token)
	req.Header.Set("Accept", PreviewHeader)

	ctx := context.Background()
	if err := client.Run(ctx, req, &res); err != nil {
		logE.Fatalf(`event="Exiting" error="%v"`, errors.Wrap(err, "client failed to call github api"))
	}

	// Reinitialise some counts we're about to redo
	report.DismissedVulnerabilities = 0

	// Index the found vulnerabilities into the current baseline report if there
	// are any for each repository
	for _, repo := range res.repos().Nodes {
		if repo.VulnerabilityAlerts.TotalCount > 0 {
			for _, vuln := range repo.VulnerabilityAlerts.Nodes {
				// Skip if dismissed
				if len(vuln.DismissedAt) > 0 {
					report.DismissedVulnerabilities = report.DismissedVulnerabilities + 1
					continue
				}
				// Instantiate the maps if we don't already have them
				if _, ok := report.Repos[repo.Name]; !ok {
					report.Repos[repo.Name] = make(map[string]Vulnerability)
				}
				report.Repos[repo.Name][vuln.ID] = vuln
			}
		}
	}

	report.LastChecked = c.Entries()[0].Prev.Format(time.RFC3339)
	report.NextCheckScheduled = c.Entries()[0].Next.Format(time.RFC3339)
}

func startWebserver() {
	r := httprouter.New()
	r.GET("/report", reportHandler)
	r.GET("/info", infoHandler)

	srv = &http.Server{
		Addr:         fmt.Sprintf(":%s", port),
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
		Handler:      r,
	}

	// TODO look at more graceful shutdowns
	log.Printf(`event="Starting webserver" port="%s"`, port)
	if err := srv.ListenAndServe(); err != http.ErrServerClosed {
		logE.Fatalf(`event="Stopped" error="%v"`, srv.ListenAndServe())
	}
}

func infoHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	info := struct {
		Healthy bool `json:"healthy"`
	}{
		true,
	}

	out, err := json.Marshal(&info)
	if err != nil {
		api.WriteProblemResponse(api.Problem{Title: "Unable to marshal info response"}, w)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(out)
}

func reportHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	w.Header().Set("Content-Type", "application/json")
	reportJSON, err := json.Marshal(report)
	if err != nil {
		api.WriteProblemResponse(api.Problem{Title: "Unable to marshal response"}, w)
		return
	}
	w.WriteHeader(http.StatusOK)
	w.Write(reportJSON)
}

// IDPrefix is the constant node id prefix of a github vulnerability alert
const IDPrefix = "028:RepositoryVulnerabilityAlert"

// ConvertAPIIDToNodeID takes a github v4 id and converts it to a node id of a
// repository vulnerability
func ConvertAPIIDToNodeID(id string) (nodeID string) {
	return base64.StdEncoding.EncodeToString([]byte(IDPrefix + id))
}

// ConvertNodeIDToAPIID takes an encoded repository vulnerability node id and
// converts it to a github api v4 id
func ConvertNodeIDToAPIID(nodeID string) (id string) {
	decoded, err := base64.StdEncoding.DecodeString(nodeID)
	if err != nil {
		return ""
	}
	return string(bytes.TrimPrefix(decoded, []byte(IDPrefix)))
}
