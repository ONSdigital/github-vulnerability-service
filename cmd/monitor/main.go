package main

// See: https://blog.machinebox.io/a-graphql-client-library-for-go-5bffd0455878

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"syscall"
	"time"

	"github.com/ONSdigital/github-vulnerability-monitor/pkg/api"
	"github.com/ONSdigital/github-vulnerability-monitor/pkg/githook"
	"github.com/ONSdigital/github-vulnerability-monitor/pkg/signals"
	"github.com/julienschmidt/httprouter"
	"github.com/machinebox/graphql"

	"encoding/base64"
)

// Various fixed values for interacting with the Github graphql api
const (
	APIURL        = "https://api.github.com/graphql"
	PreviewHeader = "application/vnd.github.vixen-preview+json"
)

// The cache of the currently loaded vulnerability report
var report map[string]map[string]vulnerability

// Vulnerability describes a vulnerability reported for a repository
type vulnerability struct {
	AffectedRange string `json:"affectedRange,omitempty"`
	DismissReason string `json:"dismissReason,omitempty"`
	DismissedAt   string `json:"dismissedAt,omitempty"`
	Dismisser     struct {
		Name string `json:"name"`
	} `json:"dimisser,omitempty"`
	ExternalIdentifier string `json:"externalIdentifier,omitempty"`
	ExternalReference  string `json:"externalReference,omitempty"`
	FixedIn            string `json:"fixedIn,omitempty"`
	PackageName        string `json:"packageName,omitempty"`
	ID                 string `json:"id"`
}

type (
	response interface {
		repos() repositories
	}

	repositories struct {
		TotalCount int
		Nodes      []struct {
			Name                string
			VulnerabilityAlerts struct {
				TotalCount int
				PageInfo   struct {
					EndCursor       string
					HasNextPage     bool
					HasPreviousPage bool
					StartCursor     string
				}
				Nodes []vulnerability
			}
		}
	}
)

type teamResponse struct {
	Organization struct {
		Team struct {
			Repositories repositories
		}
	}
}

func (r teamResponse) repos() repositories {
	return r.Organization.Team.Repositories
}

type userResponse struct {
	User struct {
		Repositories repositories
	}
}

func (r userResponse) repos() repositories {
	return r.User.Repositories
}

var (
	token  string // Github API access token
	port   string // Port on which to listen for webhooks
	secret []byte // Webhook signing secret

	logE = log.New(os.Stderr, "", log.Ldate|log.Ltime)

	org, team, user string
)

func main() {

	// Initialise report storage
	report = make(map[string]map[string]vulnerability)

	if token = os.Getenv("TOKEN"); len(token) == 0 {
		logE.Fatal("Must set Github API TOKEN env var")
	}

	if port = os.Getenv("PORT"); len(port) == 0 {
		logE.Fatal(`event="Failed to start" error="missing PORT env"`)
	}

	if secret = []byte(os.Getenv("WEBHOOK_SECRET")); len(secret) == 0 {
		logE.Fatal(`event="Failed to start" error="missing WEBHOOK_SECRET env"`)
	}

	org = os.Getenv("GITHUB_ORG")
	team = os.Getenv("GITHUB_TEAM")
	user = os.Getenv("GITHUB_USER")

	// Bootstrap an initial vulneranility report
	client := graphql.NewClient(APIURL)
	bootstrapVulnerabilityReport(client)

	// Start up the webserver to watch for webhooks
	cancelSigWatch := signals.HandleFunc(
		func(sig os.Signal) {
			log.Printf(`event="Shutting down" signal="%s"`, sig.String())
			log.Print(`event="Exiting"`)
			os.Exit(0)
		},
		syscall.SIGTERM,
		syscall.SIGINT,
	)
	defer cancelSigWatch()

	startWebhookWatcher()
}

func bootstrapVulnerabilityReport(client *graphql.Client) {
	coreRequest := `
	repositories(first: 100) {
		totalCount
		nodes {
			name
			vulnerabilityAlerts(first: 10) {
				totalCount
				pageInfo {
					endCursor
					hasNextPage
					hasPreviousPage
					startCursor
				}
				nodes {
					affectedRange
					dismissReason
					dismissedAt
					dismisser{
						name
					}
					externalIdentifier
					externalReference
					fixedIn
					id
					packageName
				}
			}
		}
	}
	`

	var req *graphql.Request
	var res response

	switch {
	default:
		log.Fatal("Must set either USER or ORG and TEAM env vars")

	case len(user) > 0:
		log.Printf("Starting in USER mode for '%s'\n", user)

		req = graphql.NewRequest(`
		query($user: String!) {
			user(login: $user) {
				` + coreRequest + `
			}
		}
		`)
		req.Var("user", user)

		res = &userResponse{}

	case len(team) > 0 && len(org) > 0:
		log.Printf("Starting in TEAM mode for '%s:%s'\n", org, team)

		req = graphql.NewRequest(`
		query($organization: String!, $team: String!) {
			organization(login: $organization) {
				team(slug: $team) {
					` + coreRequest + `
				}
			}
		}
		`)
		req.Var("organization", org)
		req.Var("team", team)

		res = &teamResponse{}
	}

	req.Header.Set("Authorization", "bearer "+token)
	req.Header.Set("Accept", PreviewHeader)

	ctx := context.Background()
	if err := client.Run(ctx, req, &res); err != nil {
		log.Fatal(err)
		// TODO More graceful handling of fatal error!
		// ...
	}

	// Index the found vulnerabilities into the current baseline report if there
	// are any for each repository
	for _, repo := range res.repos().Nodes {
		if repo.VulnerabilityAlerts.TotalCount > 0 {
			for _, vuln := range repo.VulnerabilityAlerts.Nodes {
				if _, ok := report[repo.Name]; !ok {
					report[repo.Name] = make(map[string]vulnerability)
				}
				report[repo.Name][vuln.ID] = vuln
			}
		}
	}
}

func startWebhookWatcher() {
	r := httprouter.New()
	r.POST("/webhooks", webhookHandler)
	r.GET("/report", reportHandler)
	r.GET("/healthcheck", healthcheckHandler)

	srv := &http.Server{
		Addr:         fmt.Sprintf(":%s", port),
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
		Handler:      r,
	}

	// TODO look at more graceful shutdowns
	log.Printf(`event="Starting webhook listener" port="%s"`, port)
	logE.Fatalf(`event="Stopped" error="%v"`, srv.ListenAndServe())
}

// TODO replace with an info handler
func healthcheckHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	w.Header().Set("Content-Type", "application/json")
	w.Write([]byte(`{"healthy":true}`))
	w.WriteHeader(http.StatusOK)
}

func reportHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	w.Header().Set("Content-Type", "application/json")
	reportJSON, err := json.Marshal(report)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		// TODO better error report
		// ...
		return
	}
	w.WriteHeader(http.StatusOK)
	w.Write(reportJSON)
}

func webhookHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	event, err := githook.Parse(r, secret)
	if err != nil {
		log.Printf(`event="Error parsing hook" error="%v"`, err)
		api.WriteProblemResponse(api.Problem{
			Title:  "Problem parsing request body",
			Status: http.StatusBadRequest,
			Detail: err.Error(),
		}, w)
		return
	}

	switch e := event.(type) {
	case *githook.PingEvent:
		log.Printf(`event="Received hook event" type="ping" repo="%s"`, e.Repository.FullName)
	case *githook.RepositoryVulnerabilityAlertEvent:
		log.Printf(`event="Received hook event" type="vulnerability" repo="%s" action="%s"`, e.Repository.FullName, e.Action)
		// ...
		// TODO process the vulnerability to the cache for disply
		// ...

		nodeID := ConvertAPIIDToNodeID(strconv.Itoa(e.Alert.ID))

		switch e.Action {
		default:
			logE.Printf(`event="Received unknown webhook action" action="%s"`, e.Action)
			api.WriteProblemResponse(api.Problem{Status: http.StatusNotImplemented}, w)
			return
		case "create":

			if _, ok := report[e.Repository.Name]; !ok {
				report[e.Repository.Name] = make(map[string]vulnerability)
			}

			report[e.Repository.Name][nodeID] = vulnerability{
				AffectedRange:      e.Alert.AffectedRange,
				ExternalIdentifier: e.Alert.ExternalIdentifier,
				ExternalReference:  e.Alert.ExternalReference,
				FixedIn:            e.Alert.FixedIn,
				PackageName:        e.Alert.AffectedPackageName,
				ID:                 nodeID,
			}

			break
		case "dismiss":

			// Naively destroy the record for now
			if r, ok := report[e.Repository.Name]; ok {
				if _, ok := r[nodeID]; ok {
					delete(report[e.Repository.Name], nodeID)
				}
			}

			// TODO Clean up repo from map if last vulnerability was removed

			break
		case "resolve":

			// Naively destroy the record for now
			if r, ok := report[e.Repository.Name]; ok {
				if _, ok := r[nodeID]; ok {
					delete(report[e.Repository.Name], nodeID)
				}
			}

			// TODO Clean up repo from map if last vulnerability was removed

			break
		}

	}

	w.WriteHeader(http.StatusOK)
	return
}

// IDPrefix is the constant node id prefix of a github vulnerability alert
const IDPrefix = "028:RepositoryVulnerabilityAlert"

// ConvertAPIIDToNodeID takes a github v4 id and converts it to a node id of a
// repository vulnerability
func ConvertAPIIDToNodeID(id string) (nodeID string) {
	return base64.StdEncoding.EncodeToString([]byte(IDPrefix + id))
}

// ConvertNodeIDToAPIID takes an encoded repository vulnerability node id and
// converts it to a github api v4 id
func ConvertNodeIDToAPIID(nodeID string) (id string) {
	decoded, err := base64.StdEncoding.DecodeString(nodeID)
	if err != nil {
		return ""
	}
	return string(bytes.TrimPrefix(decoded, []byte(IDPrefix)))
}
